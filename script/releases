#!/usr/bin/env node

const fs = require('fs')
const path = require('path')
const semver = require('semver')
const hubdown = require('hubdown')
const GitHub = require('github')
const parseLinkHeader = require('parse-link-header')
const versions = require('../data/versions.json')
const github = new GitHub()

github.authenticate({
  type: 'token', 
  token: 'da809a6077bb1b0aa7c5623f7b2d5f1fec2faae4'
})

console.log('Fetching electron/electron releases from the GitHub API')

function ghOpts(opts) {
  const defaults = {
    owner: 'electron',
    repo: 'electron',
    per_page: 100
  }
  return Object.assign({}, defaults, opts)
}

async function getReleases () {

  // determine number of pages
  const countRes = await github.repos.getReleases(
    Object.assign(ghOpts({per_page: 1}))
  )
  try {
    const count = Number(parseLinkHeader(countRes.meta.link).last.page)
    const pagesToFetch = Math.ceil(count / 100)
  } catch(err) {
    console.error('problem fetching number of releases')
    console.error(err)
    process.exit(1)
  }

  // paginate
  let releases = []
  for (let i = 1; i <= pagesToFetch; i++) {
    const batch = await github.repos.getReleases(ghOpts({page: i}))
    releases = releases.concat(batch.data)
  }

  return Promise.all(releases
    .filter(release => !(release.draft || release.prerelease))
    .filter(release => semver.valid(release.tag_name.substring(1)))
    .map(processRelease)
  )
}

async function processRelease(release) {
  release.version = release.tag_name.substring(1)  
  release.body = release.body
  
  // turn PR references like #123 into hyperlinks
  .replace(
    / #(\d+)$/gm,
    ' <a href="https://github.com/electron/electron/pull/$1">#$1</a>'
  )

  // adjust heading levels (h2 becomes h3, etc)
  .replace(/^#### /gm, '##### ')
  .replace(/^### /gm, '#### ')
  .replace(/^## /gm, '### ')

  const parsed = await hubdown(release.body)
  release.body_html = parsed.content
  
  return release
}

getReleases().then(releases => {

  releases = releases
    .sort((a, b) => semver.compare(b.version, a.version))
    
    // inject version data for v8, node, chromium, etc
    .map(release => {
      const deps = versions.find(version => version.version === release.version)

      if (deps) release.dependencyVersions = deps

      return release
    })

  console.log(releases.map(release => release.version).join('\n'))

  fs.writeFileSync(
    path.join(__dirname, '../data/releases.json'), 
    JSON.stringify(releases, null, 2)
  )
})

